#!python3
#-*- coding: utf-8 -*-

import argparse
import json
import os
import re
from itertools import groupby
from math import exp, log

import irsdk
import requests
from prettytable import PrettyTable

import config as cfg
from ir_webstats.ir_webstats.client import iRWebStats

denom = 1600/log(2)

# set up our command line option for debugging
parser = argparse.ArgumentParser()
parser.add_argument("--debug", action='store_true')
args = parser.parse_args()

debug = False
if args.debug:
	debug = True


def median(mylist):
	""" Returns the median of a list of numbers """
	sorts = sorted(mylist)
	length = len(sorts)
	if not length % 2:
		return (sorts[length // 2] + sorts[length // 2 - 1]) / 2.0
	return sorts[length // 2]


def score(pos, compet, scenario):
	posiR= [placement['iR'] for placement in scenario if placement['place'] == pos][0]
	competiR = [placement['iR'] for placement in scenario if placement['place'] == compet][0]
	return ((1-exp(-posiR/denom))*(exp(-competiR/denom)))/((1-exp(-competiR/denom))*(exp(-posiR/denom))+(1-exp(-posiR/denom))*(exp(-competiR/denom)))


def fudge(place, scenario):
	return ((len(scenario))/2-place)/100


def ir_Delta(place, scenario):
	return (len(scenario)-place-(sum(map(lambda c: score(place, c, scenario), range(1, len(scenario)+1)))-0.5)-fudge(place, scenario))*200/len(scenario)


def get_name(drv, mc, irw, cls):
	global my_cls
	nameParts = drv["UserName"].split(' ')
	name = [nameParts[-1], nameParts[0]]
	# if this isn't a multiclass race we have an extra 4 chars
	if not mc:
		# if the lastname is over 20 chars in length, trim it
		name = "%s %s" % (name[1][:1], name[0][:20])
		# pad all the names out to be 22 chars total
		name = '{0: <22}'.format(name)
	else:
		# if the lastname is over 15 chars in length, trim it
		name = "%s %s" % (name[1][:1], name[0][:15])
		# pad all the names out to be 17 chars total
		name = '{0: <17}'.format(name)

	# finally lets sort out any special chars so all names will be displayed correctly in the windows console
	name = name.encode('windows-1252', errors='replace').decode('windows-1252', errors='replace')

	# is this driver our user?
	if irw.custid == str(drv['UserID']):
		# then this is their car type
		my_cls = cls
		# wack > < around their name to highlight it
		name = ">%s<" % name[:15]

	# is this a pro driver? surround with @ @
	trimmedName = re.search('([A-Za-zÀ-ž ]*)', drv["UserName"]).group(1).rstrip()
	r = requests.get(f'https://www.driverdb.com/autocomp/?term={trimmedName}')
	if r.status_code == 200 and len(r.text):
		name = "@%s@" % name[:15]

	return name


def build_row(drv, mc, irw, cls, web_api, seriesid, classPos):
	name = get_name(drv, mc, irw, cls)
	# collect all the basic info up into a new row
	row = ([classPos, cls, name, drv['LicString'], drv['IRating']])

	# if we do have a connection to the website, lets do all this extra stuff
	if web_api:
		# get the last 3 series this driver has raced in
		drv_last_series = irw.last_series(drv['UserID'])
		series_stats = False
		for s in drv_last_series:
			# is the series which this race is part of one of those 3?
			if s['seriesID'] == seriesid and not series_stats:
				# sweet it is!
				series_stats = True
				# the number of starts they've had in the series
				row.append(s['starts'])
				# the driver's standing in the championship
				row.append(s['position'])
				# the average finish position
				row.append(s['avgFinish'])
				# average incidents per race
				avginc = "%.0f" % float(int(s['incidents']) // int(s['starts']))
				row.append(avginc)

		# if we can't get this driver's stats for this series, blank out these cols in their row
		if not series_stats:
			row.append('{0: <5}'.format(""))
			row.append('{0: <5}'.format(""))
			row.append('{0: <5}'.format(""))
			row.append('{0: <5}'.format(""))

	return row


def add_iRcolumn(tab, drv_by_class, custID):
	# Show the expected change in iRating for finishing in each position
	iRDelta = []
	for (cls, cls_drivers) in drv_by_class.items():
		if my_cls != cls:
			iRDelta.extend([None] * len(cls_drivers))
			continue
		iRmap = {drv['UserID']: drv['IRating'] for drv in cls_drivers}
		for finPos in range(1, len(cls_drivers) + 1):
			scenario = [{'place': finPos, 'iR': iRmap[custID]}] + \
					   [{'place': pos, 'iR': iR} for (pos, iR) in zip([pos for pos in range(1, len(cls_drivers) + 1) if pos != finPos],
																	  [iR for (custId, iR) in iRmap.items() if
																	   custId != custID])]
			iRDelta.append(int(ir_Delta(finPos, scenario)))

	# just make sure the order is right (should be since rows were generated by class)
	tab.add_column("iRDelta", list(iRDelta))


def printSOFpoints(mc, drv_by_class, unofficial):
	# iR totals by class
	ir_total = {cls: sum([drv['IRating'] for drv in drivers]) for (cls, drivers) in drv_by_class.items()}
	# iRs by class
	irs = {cls: [drv['IRating'] for drv in drivers] for (cls, drivers) in drv_by_class.items()}
	# driver count by class
	drv_count = {cls: len(drivers) for (cls, drivers) in drv_by_class.items()}

	# strength of field math: we take the average and add it to the median and divide by 2 and we seem to get close enough
	sof = float(((int(ir_total[my_cls]) / int(drv_count[my_cls])) + int(median(irs[my_cls]))) / 2)

	# the sof divided by 16 gets us pretty damn close to the winner's championship points gain
	winner_pts = sof / 16

	# this works out how the points step down each finishing position
	pts_diff = (winner_pts / (drv_count[my_cls] - 1))

	# show the guestimated strength of field
	print(f'Approx SOF' + (f' of {my_cls}' if mc else '') + f': {sof:.0f}')

	# only show points if this race went official
	if not unofficial:
		print(f'Approx PTS' + (f' for {my_cls}: ' if mc else ': ') + ' | '.join([f'{pos+1}: {winner_pts - pts_diff*pos:.0f}' for pos in range(0, drv_count[my_cls])[:5]]))
	else:
		# else tell them this isn't an official race, so no points for you
		print("Race is UNOFFICIAL, no PTS will be awarded")


def main():
	# local iRacing API
	ir = irsdk.IRSDK()

	# iRacing.com website API
	irw = iRWebStats()

	# a pretty looking splash screen, because branding
	print("                    ____                  ___        __                        ")
	print("                   |  _ \ __ _  ___ ___  |_ _|_ __  / _| ___                   ")
	print("                   | |_) / _` |/ __/ _ \  | || '_ \| |_ / _ \                  ")
	print("                   |  _ < (_| | (_|  __/  | || | | |  _| (_) |                 ")
	print("                   |_| \_\__,_|\___\___| |___|_| |_|_|  \___/                  ")
	print("                                                                               ")
	print("                                                                               ")
	print("                      v1.200510                                                ")
	print("                      Created by Robert \"Fuzzwah\" Crouch                     ")
	print("                      http://fuzzysracing.blogspot.com                         ")
	print("                                                                               ")
	print("                                                                               ")

	# try to read in a config file
	cfg.read("config.ini")
	# if the password is blank, lets prompt the user for their details and save them
	if cfg.config['password'] == '':
		cfg.config['username'] = str(input('Your iRacing username: '))
		cfg.config['password'] = str(input('Your iRacing password: '))

		cfg.config.write()
		print("                                 Config saved                                  ")
		print("                                                                               ")

	# check if the local API can talk to the game, ie: is iRacing running
	if ir.startup():
		if any(['Race' == ses['SessionType'] for ses in ir['SessionInfo']['Sessions']]):
			# let the user know if we're in debug mode and dump the info files
			if debug:
				print("                                                                               ")
				print("                               *** DEBUG ON ***                                ")
				print("                           Dumping info to text files                          ")
				print("                                                                               ")
				json.dump(ir['SessionInfo'], open("SessionInfo.txt",'w'), sort_keys=True, indent=4, separators=(',', ': '))
				json.dump(ir['WeekendInfo'], open("WeekendInfo.txt",'w'), sort_keys=True, indent=4, separators=(',', ': '))
				json.dump(ir['QualifyResultsInfo'], open("QualifyResultsInfo.txt",'w'), sort_keys=True, indent=4, separators=(',', ': '))
				json.dump(ir['DriverInfo'], open("DriverInfo.txt",'w'), sort_keys=True, indent=4, separators=(',', ': '))

			try:
				# let the user know we're connecting to the website
				print("       Please wait, connecting to iracing.com to retrieve driver data")
				irw.login(cfg.config['username'], cfg.config['password'])
				web_api = True
			except:
				# if it didn't work we'll set up only the minimal table
				web_api = False
				print("Unable to log into iRacing.com")

			seriesid = ir['WeekendInfo']['SeriesID']
			# is it multiclass?
			mc = ir['WeekendInfo']['NumCarClasses'] > 1
			# Split into classes first
			drv_by_class = {cls: [drv for drv in list(group) if drv['CarNumberRaw']] for cls, group in groupby(ir['DriverInfo']['Drivers'], key= lambda drv: drv['CarClassShortName']) if cls or not mc}
			if not drv_by_class:
				print("Not supported for replay of a multiclass race session")
				exit(1)
			# total drivers
			count = sum([len(drivers) for (_, drivers) in drv_by_class.items()])
			# process all the drivers
			rows = [build_row(drv, mc, irw, cls, web_api, seriesid, classPos) for (cls, cls_drivers) in drv_by_class.items() for (drv, classPos) in zip(cls_drivers, range(1, len(cls_drivers)+1))]

			# Table creation
			core_cols = ['#', 'Class', 'Name', 'License', 'iR']
			webapi_cols = ['Races', 'SPos', 'AFin', 'AInc']
			tab = PrettyTable(core_cols + (webapi_cols if web_api else []))
			display = core_cols + (webapi_cols if web_api else []) + ['iRDelta']
			for col in (col for col in display if col != 'Name'):
				tab.align[col] = 'r'
			tab.align['Name'] = 'l'
			for row in rows:
				tab.add_row(row)
			add_iRcolumn(tab, drv_by_class, int(irw.custid))

			# this sets the height of our window so it fits everything neatly
			os.system("mode con lines=%s" % (count + 11))
			# lets clear our splash screen and please wait message because we're ready to display our awesome table!
			os.system('cls' if os.name == 'nt' else 'clear')
			print(" ")
			printSOFpoints(mc, drv_by_class, ir['WeekendInfo']['WeekendOptions']['Unofficial'])
			print(" ")
			print(tab.get_string(sortby='Class', fields=display))

		else:
			print("*** ERROR *** This is not a race session")
			print("Race Info only generates details for races")
	else:
		print("*** ERROR *** iRacing is not running")
		print("Join the race session first, then run Race Info")

	print(" ")
	# go on, press it.... or click close... or alt-f4... whatever, I don't care
	input("Press Enter to close ...")


if __name__ == "__main__":
	main()